"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/products/[id]/page",{

/***/ "(app-pages-browser)/./utils/imageUtils.ts":
/*!*****************************!*\
  !*** ./utils/imageUtils.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCloudinaryUrl: function() { return /* binding */ getCloudinaryUrl; },\n/* harmony export */   getImageUrl: function() { return /* binding */ getImageUrl; },\n/* harmony export */   getImageUrlForEnv: function() { return /* binding */ getImageUrlForEnv; },\n/* harmony export */   getMainImageForColor: function() { return /* binding */ getMainImageForColor; },\n/* harmony export */   isValidImageUrl: function() { return /* binding */ isValidImageUrl; },\n/* harmony export */   loadImageWithFallback: function() { return /* binding */ loadImageWithFallback; }\n/* harmony export */ });\n// Utility function to get the correct image URL\nconst getImageUrl = (imagePath)=>{\n    if (!imagePath) {\n        return \"/images/placeholder-product.svg\";\n    }\n    // If it's already a full URL (Cloudinary or other), return as is\n    if (imagePath.startsWith(\"http://\") || imagePath.startsWith(\"https://\")) {\n        return imagePath;\n    }\n    // Get backend URL from environment or default\n    const backendUrl = \"http://localhost:5001\" || 0;\n    // If it's a relative path starting with /uploads, construct the full backend URL\n    if (imagePath.startsWith(\"/uploads/\")) {\n        return \"\".concat(backendUrl).concat(imagePath);\n    }\n    // If it's just a filename, construct the full path\n    if (!imagePath.startsWith(\"/\")) {\n        return \"\".concat(backendUrl, \"/uploads/products/\").concat(imagePath);\n    }\n    // For local images in public folder\n    return imagePath;\n};\n// Utility function to get the correct image URL for the current environment\nconst getImageUrlForEnv = (imagePath)=>{\n    const backendUrl = \"http://localhost:5001\" || 0;\n    if (!imagePath) return \"/images/products/hero-product-image.jpg\";\n    // If the image path is already a full URL, return it as is\n    if (imagePath.startsWith(\"http://\") || imagePath.startsWith(\"https://\")) {\n        return imagePath;\n    }\n    // If it's a relative path starting with /uploads, construct the full URL\n    if (imagePath.startsWith(\"/uploads/\")) {\n        return \"\".concat(backendUrl).concat(imagePath);\n    }\n    // If it's just a filename, construct the full path\n    if (!imagePath.startsWith(\"/\")) {\n        return \"\".concat(backendUrl, \"/uploads/products/\").concat(imagePath);\n    }\n    // For local images in public folder\n    return imagePath;\n};\n// Function to check if image URL is valid\nconst isValidImageUrl = (url)=>{\n    return Boolean(url && url.length > 0 && url !== \"/images/placeholder-product.svg\");\n};\n// Function to get optimized Cloudinary image URL\nconst getCloudinaryUrl = function(imagePath) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!imagePath) {\n        return \"/images/placeholder-product.svg\";\n    }\n    // If it's not a Cloudinary URL, return as is\n    if (!imagePath.includes(\"res.cloudinary.com\")) {\n        return getImageUrl(imagePath);\n    }\n    // Build transformation parameters\n    const transformations = [];\n    if (options.width || options.height) {\n        const size = [];\n        if (options.width) size.push(\"w_\".concat(options.width));\n        if (options.height) size.push(\"h_\".concat(options.height));\n        if (options.crop) size.push(\"c_\".concat(options.crop));\n        if (size.length > 0) transformations.push(size.join(\",\"));\n    }\n    if (options.quality) {\n        transformations.push(\"q_\".concat(options.quality));\n    }\n    if (options.format) {\n        transformations.push(\"f_\".concat(options.format));\n    }\n    // Insert transformations into Cloudinary URL\n    if (transformations.length > 0) {\n        const urlParts = imagePath.split(\"/\");\n        const insertIndex = urlParts.findIndex((part)=>part === \"upload\") + 1;\n        urlParts.splice(insertIndex, 0, transformations.join(\"/\"));\n        return urlParts.join(\"/\");\n    }\n    return imagePath;\n};\n// Function to safely load an image with fallback (Client-side only)\nconst loadImageWithFallback = (imagePath, onSuccess, onError)=>{\n    const imageUrl = getImageUrl(imagePath);\n    // Only run in browser environment\n    if (true) {\n        // Create a temporary image element to test loading\n        const img = new Image();\n        img.onload = ()=>{\n            console.log(\"✅ Image loaded successfully:\", imageUrl);\n            onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(imageUrl);\n        };\n        img.onerror = ()=>{\n            console.error(\"❌ Image failed to load:\", imageUrl);\n            const fallbackUrl = \"/images/placeholder-product.svg\";\n            console.log(\"\\uD83D\\uDD04 Using fallback image:\", fallbackUrl);\n            onError === null || onError === void 0 ? void 0 : onError(\"Failed to load: \".concat(imageUrl));\n        };\n        // Start loading the image\n        img.src = imageUrl;\n    }\n    return imageUrl;\n};\n// Helper function to get the main image for a specific color\nconst getMainImageForColor = (product, colorName)=>{\n    if (!product || !product.images || product.images.length === 0) {\n        return null;\n    }\n    // First try to find color-specific images (excluding color representation images)\n    const colorImages = product.images.filter((img)=>img.color === colorName && img.isColorRepresentation !== true);\n    if (colorImages.length > 0) {\n        // Return the first image for this color (maintains original order)\n        // If there's a primary image, prioritize it, otherwise return first\n        const primaryImage = colorImages.find((img)=>img.isPrimary);\n        return primaryImage || colorImages[0];\n    }\n    // If no color-specific images, return general images (color: null or undefined)\n    const generalImages = product.images.filter((img)=>(img.color === null || img.color === undefined) && img.isColorRepresentation !== true);\n    if (generalImages.length > 0) {\n        const primaryImage = generalImages.find((img)=>img.isPrimary);\n        return primaryImage || generalImages[0];\n    }\n    // Fallback to any image\n    return product.images[0];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2ltYWdlVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsZ0RBQWdEO0FBQ3pDLE1BQU1BLGNBQWMsQ0FBQ0M7SUFDMUIsSUFBSSxDQUFDQSxXQUFXO1FBQ2QsT0FBTztJQUNUO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUlBLFVBQVVDLFVBQVUsQ0FBQyxjQUFjRCxVQUFVQyxVQUFVLENBQUMsYUFBYTtRQUN2RSxPQUFPRDtJQUNUO0lBRUEsOENBQThDO0lBQzlDLE1BQU1FLGFBQWFDLHVCQUErQixJQUFJO0lBRXRELGlGQUFpRjtJQUNqRixJQUFJSCxVQUFVQyxVQUFVLENBQUMsY0FBYztRQUNyQyxPQUFPLEdBQWdCRCxPQUFiRSxZQUF1QixPQUFWRjtJQUN6QjtJQUVBLG1EQUFtRDtJQUNuRCxJQUFJLENBQUNBLFVBQVVDLFVBQVUsQ0FBQyxNQUFNO1FBQzlCLE9BQU8sR0FBa0NELE9BQS9CRSxZQUFXLHNCQUE4QixPQUFWRjtJQUMzQztJQUVBLG9DQUFvQztJQUNwQyxPQUFPQTtBQUNULEVBQUM7QUFFRCw0RUFBNEU7QUFDckUsTUFBTU0sb0JBQW9CLENBQUNOO0lBQ2hDLE1BQU1FLGFBQWFDLHVCQUErQixJQUFJO0lBRXRELElBQUksQ0FBQ0gsV0FBVyxPQUFPO0lBRXZCLDJEQUEyRDtJQUMzRCxJQUFJQSxVQUFVQyxVQUFVLENBQUMsY0FBY0QsVUFBVUMsVUFBVSxDQUFDLGFBQWE7UUFDdkUsT0FBT0Q7SUFDVDtJQUVBLHlFQUF5RTtJQUN6RSxJQUFJQSxVQUFVQyxVQUFVLENBQUMsY0FBYztRQUNyQyxPQUFPLEdBQWdCRCxPQUFiRSxZQUF1QixPQUFWRjtJQUN6QjtJQUVBLG1EQUFtRDtJQUNuRCxJQUFJLENBQUNBLFVBQVVDLFVBQVUsQ0FBQyxNQUFNO1FBQzlCLE9BQU8sR0FBa0NELE9BQS9CRSxZQUFXLHNCQUE4QixPQUFWRjtJQUMzQztJQUVBLG9DQUFvQztJQUNwQyxPQUFPQTtBQUNULEVB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O1FBQ25FLG9FQUFvRTtRQUNwRSxNQUFNd0MsZUFBZUosWUFBWUssSUFBSSxDQUFDLENBQUNsQixNQUFhQSxJQUFJbUIsU0FBUztRQUNqRSxPQUFPRixnQkFBZ0JKLFdBQVcsQ0FBQyxFQUFFO0lBQ3ZDO0lBRUEsZ0ZBQWdGO0lBQ2hGLE1BQU1PLGdCQUFnQlYsUUFBUUUsTUFBTSxDQUFDRSxNQUFNLENBQUMsQ0FBQ2QsTUFDM0MsQ0FBQ0EsSUFBSWUsS0FBSyxLQUFLLFFBQVFmLElBQUllLEtBQUssS0FBS00sU0FBUSxLQUM3Q3JCLElBQUlnQixxQkFBcUIsS0FBSztJQUdoQyxJQUFJSSxjQUFjM0MsTUFBTSxHQUFHLEdBQUc7UUFDNUIsTUFBTXdDLGVBQWVHLGNBQWNGLElBQUksQ0FBQyxDQUFDbEIsTUFBYUEsSUFBSW1CLFNBQVM7UUFDbkUsT0FBT0YsZ0JBQWdCRyxhQUFhLENBQUMsRUFBRTtJQUN6QztJQUVBLHdCQUF3QjtJQUN4QixPQUFPVixRQUFRRSxNQUFNLENBQUMsRUFBRTtBQUMxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2ltYWdlVXRpbHMudHM/YTEwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBpbWFnZSBVUkxcbmV4cG9ydCBjb25zdCBnZXRJbWFnZVVybCA9IChpbWFnZVBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGlmICghaW1hZ2VQYXRoKSB7XG4gICAgcmV0dXJuICcvaW1hZ2VzL3BsYWNlaG9sZGVyLXByb2R1Y3Quc3ZnJ1xuICB9XG4gIFxuICAvLyBJZiBpdCdzIGFscmVhZHkgYSBmdWxsIFVSTCAoQ2xvdWRpbmFyeSBvciBvdGhlciksIHJldHVybiBhcyBpc1xuICBpZiAoaW1hZ2VQYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBpbWFnZVBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIHJldHVybiBpbWFnZVBhdGhcbiAgfVxuICBcbiAgLy8gR2V0IGJhY2tlbmQgVVJMIGZyb20gZW52aXJvbm1lbnQgb3IgZGVmYXVsdFxuICBjb25zdCBiYWNrZW5kVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAxJ1xuICBcbiAgLy8gSWYgaXQncyBhIHJlbGF0aXZlIHBhdGggc3RhcnRpbmcgd2l0aCAvdXBsb2FkcywgY29uc3RydWN0IHRoZSBmdWxsIGJhY2tlbmQgVVJMXG4gIGlmIChpbWFnZVBhdGguc3RhcnRzV2l0aCgnL3VwbG9hZHMvJykpIHtcbiAgICByZXR1cm4gYCR7YmFja2VuZFVybH0ke2ltYWdlUGF0aH1gXG4gIH1cbiAgXG4gIC8vIElmIGl0J3MganVzdCBhIGZpbGVuYW1lLCBjb25zdHJ1Y3QgdGhlIGZ1bGwgcGF0aFxuICBpZiAoIWltYWdlUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICByZXR1cm4gYCR7YmFja2VuZFVybH0vdXBsb2Fkcy9wcm9kdWN0cy8ke2ltYWdlUGF0aH1gXG4gIH1cbiAgXG4gIC8vIEZvciBsb2NhbCBpbWFnZXMgaW4gcHVibGljIGZvbGRlclxuICByZXR1cm4gaW1hZ2VQYXRoXG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGltYWdlIFVSTCBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbmV4cG9ydCBjb25zdCBnZXRJbWFnZVVybEZvckVudiA9IChpbWFnZVBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGJhY2tlbmRVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjUwMDEnXG4gIFxuICBpZiAoIWltYWdlUGF0aCkgcmV0dXJuICcvaW1hZ2VzL3Byb2R1Y3RzL2hlcm8tcHJvZHVjdC1pbWFnZS5qcGcnXG4gIFxuICAvLyBJZiB0aGUgaW1hZ2UgcGF0aCBpcyBhbHJlYWR5IGEgZnVsbCBVUkwsIHJldHVybiBpdCBhcyBpc1xuICBpZiAoaW1hZ2VQYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBpbWFnZVBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIHJldHVybiBpbWFnZVBhdGhcbiAgfVxuICBcbiAgLy8gSWYgaXQncyBhIHJlbGF0aXZlIHBhdGggc3RhcnRpbmcgd2l0aCAvdXBsb2FkcywgY29uc3RydWN0IHRoZSBmdWxsIFVSTFxuICBpZiAoaW1hZ2VQYXRoLnN0YXJ0c1dpdGgoJy91cGxvYWRzLycpKSB7XG4gICAgcmV0dXJuIGAke2JhY2tlbmRVcmx9JHtpbWFnZVBhdGh9YFxuICB9XG4gIFxuICAvLyBJZiBpdCdzIGp1c3QgYSBmaWxlbmFtZSwgY29uc3RydWN0IHRoZSBmdWxsIHBhdGhcbiAgaWYgKCFpbWFnZVBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcmV0dXJuIGAke2JhY2tlbmRVcmx9L3VwbG9hZHMvcHJvZHVjdHMvJHtpbWFnZVBhdGh9YFxuICB9XG4gIFxuICAvLyBGb3IgbG9jYWwgaW1hZ2VzIGluIHB1YmxpYyBmb2xkZXJcbiAgcmV0dXJuIGltYWdlUGF0aFxufVxuXG4vLyBGdW5jdGlvbiB0byBjaGVjayBpZiBpbWFnZSBVUkwgaXMgdmFsaWRcbmV4cG9ydCBjb25zdCBpc1ZhbGlkSW1hZ2VVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4odXJsICYmIHVybC5sZW5ndGggPiAwICYmIHVybCAhPT0gJy9pbWFnZXMvcGxhY2Vob2xkZXItcHJvZHVjdC5zdmcnKVxufVxuXG4vLyBGdW5jdGlvbiB0byBnZXQgb3B0aW1pemVkIENsb3VkaW5hcnkgaW1hZ2UgVVJMXG5leHBvcnQgY29uc3QgZ2V0Q2xvdWRpbmFyeVVybCA9IChpbWFnZVBhdGg6IHN0cmluZywgb3B0aW9uczoge1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBxdWFsaXR5PzogJ2F1dG8nIHwgJ2F1dG86Z29vZCcgfCAnYXV0bzpiZXN0JyB8IG51bWJlcjtcbiAgZm9ybWF0PzogJ2F1dG8nIHwgJ3dlYnAnIHwgJ2pwZycgfCAncG5nJztcbiAgY3JvcD86ICdmaWxsJyB8ICdsaW1pdCcgfCAnc2NhbGUnO1xufSA9IHt9KTogc3RyaW5nID0+IHtcbiAgaWYgKCFpbWFnZVBhdGgpIHtcbiAgICByZXR1cm4gJy9pbWFnZXMvcGxhY2Vob2xkZXItcHJvZHVjdC5zdmcnXG4gIH1cbiAgXG4gIC8vIElmIGl0J3Mgbm90IGEgQ2xvdWRpbmFyeSBVUkwsIHJldHVybiBhcyBpc1xuICBpZiAoIWltYWdlUGF0aC5pbmNsdWRlcygncmVzLmNsb3VkaW5hcnkuY29tJykpIHtcbiAgICByZXR1cm4gZ2V0SW1hZ2VVcmwoaW1hZ2VQYXRoKVxuICB9XG4gIFxuICAvLyBCdWlsZCB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzXG4gIGNvbnN0IHRyYW5zZm9ybWF0aW9uczogc3RyaW5nW10gPSBbXVxuICBcbiAgaWYgKG9wdGlvbnMud2lkdGggfHwgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICBjb25zdCBzaXplID0gW11cbiAgICBpZiAob3B0aW9ucy53aWR0aCkgc2l6ZS5wdXNoKGB3XyR7b3B0aW9ucy53aWR0aH1gKVxuICAgIGlmIChvcHRpb25zLmhlaWdodCkgc2l6ZS5wdXNoKGBoXyR7b3B0aW9ucy5oZWlnaHR9YClcbiAgICBpZiAob3B0aW9ucy5jcm9wKSBzaXplLnB1c2goYGNfJHtvcHRpb25zLmNyb3B9YClcbiAgICBpZiAoc2l6ZS5sZW5ndGggPiAwKSB0cmFuc2Zvcm1hdGlvbnMucHVzaChzaXplLmpvaW4oJywnKSlcbiAgfVxuICBcbiAgaWYgKG9wdGlvbnMucXVhbGl0eSkge1xuICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKGBxXyR7b3B0aW9ucy5xdWFsaXR5fWApXG4gIH1cbiAgXG4gIGlmIChvcHRpb25zLmZvcm1hdCkge1xuICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKGBmXyR7b3B0aW9ucy5mb3JtYXR9YClcbiAgfVxuICBcbiAgLy8gSW5zZXJ0IHRyYW5zZm9ybWF0aW9ucyBpbnRvIENsb3VkaW5hcnkgVVJMXG4gIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gaW1hZ2VQYXRoLnNwbGl0KCcvJylcbiAgICBjb25zdCBpbnNlcnRJbmRleCA9IHVybFBhcnRzLmZpbmRJbmRleChwYXJ0ID0+IHBhcnQgPT09ICd1cGxvYWQnKSArIDFcbiAgICB1cmxQYXJ0cy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIHRyYW5zZm9ybWF0aW9ucy5qb2luKCcvJykpXG4gICAgcmV0dXJuIHVybFBhcnRzLmpvaW4oJy8nKVxuICB9XG4gIFxuICByZXR1cm4gaW1hZ2VQYXRoXG59XG5cbi8vIEZ1bmN0aW9uIHRvIHNhZmVseSBsb2FkIGFuIGltYWdlIHdpdGggZmFsbGJhY2sgKENsaWVudC1zaWRlIG9ubHkpXG5leHBvcnQgY29uc3QgbG9hZEltYWdlV2l0aEZhbGxiYWNrID0gKFxuICBpbWFnZVBhdGg6IHN0cmluZywgXG4gIG9uU3VjY2Vzcz86ICh1cmw6IHN0cmluZykgPT4gdm9pZCwgXG4gIG9uRXJyb3I/OiAoZXJyb3I6IHN0cmluZykgPT4gdm9pZFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaW1hZ2VVcmwgPSBnZXRJbWFnZVVybChpbWFnZVBhdGgpXG4gIFxuICAvLyBPbmx5IHJ1biBpbiBicm93c2VyIGVudmlyb25tZW50XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBpbWFnZSBlbGVtZW50IHRvIHRlc3QgbG9hZGluZ1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgSW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseTonLCBpbWFnZVVybClcbiAgICAgIG9uU3VjY2Vzcz8uKGltYWdlVXJsKVxuICAgIH1cbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBJbWFnZSBmYWlsZWQgdG8gbG9hZDonLCBpbWFnZVVybClcbiAgICAgIGNvbnN0IGZhbGxiYWNrVXJsID0gJy9pbWFnZXMvcGxhY2Vob2xkZXItcHJvZHVjdC5zdmcnXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBVc2luZyBmYWxsYmFjayBpbWFnZTonLCBmYWxsYmFja1VybClcbiAgICAgIG9uRXJyb3I/LihgRmFpbGVkIHRvIGxvYWQ6ICR7aW1hZ2VVcmx9YClcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgbG9hZGluZyB0aGUgaW1hZ2VcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmxcbiAgfVxuICBcbiAgcmV0dXJuIGltYWdlVXJsXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIG1haW4gaW1hZ2UgZm9yIGEgc3BlY2lmaWMgY29sb3JcbmV4cG9ydCBjb25zdCBnZXRNYWluSW1hZ2VGb3JDb2xvciA9IChwcm9kdWN0OiBhbnksIGNvbG9yTmFtZTogc3RyaW5nKSA9PiB7XG4gIGlmICghcHJvZHVjdCB8fCAhcHJvZHVjdC5pbWFnZXMgfHwgcHJvZHVjdC5pbWFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEZpcnN0IHRyeSB0byBmaW5kIGNvbG9yLXNwZWNpZmljIGltYWdlcyAoZXhjbHVkaW5nIGNvbG9yIHJlcHJlc2VudGF0aW9uIGltYWdlcylcbiAgY29uc3QgY29sb3JJbWFnZXMgPSBwcm9kdWN0LmltYWdlcy5maWx0ZXIoKGltZzogYW55KSA9PiBcbiAgICBpbWcuY29sb3IgPT09IGNvbG9yTmFtZSAmJiBcbiAgICBpbWcuaXNDb2xvclJlcHJlc2VudGF0aW9uICE9PSB0cnVlXG4gIClcbiAgXG4gIGlmIChjb2xvckltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBpbWFnZSBmb3IgdGhpcyBjb2xvciAobWFpbnRhaW5zIG9yaWdpbmFsIG9yZGVyKVxuICAgIC8vIElmIHRoZXJlJ3MgYSBwcmltYXJ5IGltYWdlLCBwcmlvcml0aXplIGl0LCBvdGhlcndpc2UgcmV0dXJuIGZpcnN0XG4gICAgY29uc3QgcHJpbWFyeUltYWdlID0gY29sb3JJbWFnZXMuZmluZCgoaW1nOiBhbnkpID0+IGltZy5pc1ByaW1hcnkpXG4gICAgcmV0dXJuIHByaW1hcnlJbWFnZSB8fCBjb2xvckltYWdlc1swXVxuICB9XG4gIFxuICAvLyBJZiBubyBjb2xvci1zcGVjaWZpYyBpbWFnZXMsIHJldHVybiBnZW5lcmFsIGltYWdlcyAoY29sb3I6IG51bGwgb3IgdW5kZWZpbmVkKVxuICBjb25zdCBnZW5lcmFsSW1hZ2VzID0gcHJvZHVjdC5pbWFnZXMuZmlsdGVyKChpbWc6IGFueSkgPT4gXG4gICAgKGltZy5jb2xvciA9PT0gbnVsbCB8fCBpbWcuY29sb3IgPT09IHVuZGVmaW5lZCkgJiYgXG4gICAgaW1nLmlzQ29sb3JSZXByZXNlbnRhdGlvbiAhPT0gdHJ1ZVxuICApXG4gIFxuICBpZiAoZ2VuZXJhbEltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHJpbWFyeUltYWdlID0gZ2VuZXJhbEltYWdlcy5maW5kKChpbWc6IGFueSkgPT4gaW1nLmlzUHJpbWFyeSlcbiAgICByZXR1cm4gcHJpbWFyeUltYWdlIHx8IGdlbmVyYWxJbWFnZXNbMF1cbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gYW55IGltYWdlXG4gIHJldHVybiBwcm9kdWN0LmltYWdlc1swXVxufVxuIl0sIm5hbWVzIjpbImdldEltYWdlVXJsIiwiaW1hZ2VQYXRoIiwic3RhcnRzV2l0aCIsImJhY2tlbmRVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImdldEltYWdlVXJsRm9yRW52IiwiaXNWYWxpZEltYWdlVXJsIiwidXJsIiwiQm9vbGVhbiIsImxlbmd0aCIsImdldENsb3VkaW5hcnlVcmwiLCJvcHRpb25zIiwiaW5jbHVkZXMiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJ3aWR0aCIsImhlaWdodCIsInNpemUiLCJwdXNoIiwiY3JvcCIsImpvaW4iLCJxdWFsaXR5IiwiZm9ybWF0IiwidXJsUGFydHMiLCJzcGxpdCIsImluc2VydEluZGV4IiwiZmluZEluZGV4IiwicGFydCIsInNwbGljZSIsImxvYWRJbWFnZVdpdGhGYWxsYmFjayIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJpbWFnZVVybCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlcnJvciIsImZhbGxiYWNrVXJsIiwic3JjIiwiZ2V0TWFpbkltYWdlRm9yQ29sb3IiLCJwcm9kdWN0IiwiY29sb3JOYW1lIiwiaW1hZ2VzIiwiY29sb3JJbWFnZXMiLCJmaWx0ZXIiLCJjb2xvciIsImlzQ29sb3JSZXByZXNlbnRhdGlvbiIsInByaW1hcnlJbWFnZSIsImZpbmQiLCJpc1ByaW1hcnkiLCJnZW5lcmFsSW1hZ2VzIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/imageUtils.ts\n"));

/***/ })

});